/* Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. */

package avro

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"strings"
)

type CodeGenerator struct {
	rawSchema string

	structs           map[string]*bytes.Buffer
	codeSnippets      []*bytes.Buffer
	schemaDefinitions *bytes.Buffer
}

func NewCodeGenerator(schema string) *CodeGenerator {
	return &CodeGenerator{
		rawSchema:         schema,
		structs:           make(map[string]*bytes.Buffer),
		codeSnippets:      make([]*bytes.Buffer, 0),
		schemaDefinitions: &bytes.Buffer{},
	}
}

type schemaInfo struct {
	schema        *RecordSchema
	typeName      string
	schemaVarName string
	schemaErrName string
}

func newSchemaInfo(schema *RecordSchema) (*schemaInfo, error) {
	if schema.Name == "" {
		return nil, errors.New("Name not set.")
	}

	typeName := fmt.Sprintf("%s%s", strings.ToUpper(schema.Name[:1]), schema.Name[1:])

	return &schemaInfo{
		schema:        schema,
		typeName:      typeName,
		schemaVarName: fmt.Sprintf("_%s_schema", typeName),
		schemaErrName: fmt.Sprintf("_%s_schema_err", typeName),
	}, nil
}

func (this *CodeGenerator) Generate() (string, error) {
	parsedSchema, err := ParseSchema(this.rawSchema)
	if err != nil {
		return "", err
	}

	schema, ok := parsedSchema.(*RecordSchema)
	if !ok {
		return "", errors.New("Not a Record schema.")
	}
	schemaInfo, err := newSchemaInfo(schema)
	if err != nil {
		return "", err
	}

	buffer := &bytes.Buffer{}
	this.codeSnippets = append(this.codeSnippets, buffer)

	this.writePackageName(schemaInfo)

	this.writeImportStatement()

	err = this.writeStruct(schemaInfo)
	if err != nil {
		return "", err
	}

	formatted, err := format.Source([]byte(this.collectResult()))
	if err != nil {
		return "", err
	}

	return string(formatted), nil
}

func (this *CodeGenerator) collectResult() string {
	results := make([]string, len(this.codeSnippets)+1)
	for i, snippet := range this.codeSnippets {
		results[i] = snippet.String()
	}
	results[len(results)-1] = this.schemaDefinitions.String()

	return strings.Join(results, "\n")
}

func (this *CodeGenerator) writePackageName(info *schemaInfo) {
	buffer := this.codeSnippets[0]
	buffer.WriteString("package ")
	if info.schema.Namespace == "" {
		info.schema.Namespace = "avro"
	}

	packages := strings.Split(info.schema.Namespace, ".")
	buffer.WriteString(packages[len(packages)-1])
	buffer.WriteString("\n\n")
}

func (this *CodeGenerator) writeStruct(info *schemaInfo) error {
    buffer := &bytes.Buffer{}
    if _, exists := this.structs[info.typeName]; !exists {
        this.codeSnippets = append(this.codeSnippets, buffer)
        this.structs[info.typeName] = buffer
    } else {
        fmt.Printf("%s already exists, skipping\n", info.typeName)
        return nil
    }

	this.writeStructSchemaVar(info)

	this.writeDoc("", info.schema.Doc, buffer)

	err := this.writeStructDefinition(info, buffer)
	if err != nil {
		return err
	}

	buffer.WriteString("\n\n")

	err = this.writeStructConstructor(info, buffer)
	if err != nil {
		return err
	}

	buffer.WriteString("\n\n")

	this.writeSchemaGetter(info, buffer)

	return nil
}

func (this *CodeGenerator) writeFixed(schema *FixedSchema) error {
    fixedName := fmt.Sprintf("%s%s", strings.ToUpper(schema.Name[:1]), schema.Name[1:])

    buffer := &bytes.Buffer{}
    if _, exists := this.structs[fixedName]; !exists {
        this.codeSnippets = append(this.codeSnippets, buffer)
        this.structs[fixedName] = buffer
    } else {
        fmt.Printf("%s already exists, skipping\n", fixedName)
        return nil
    }

    buffer.WriteString("type ")
    buffer.WriteString(fixedName)
    buffer.WriteString(" [")
    buffer.WriteString(fmt.Sprintf("%d", schema.Size))
    buffer.WriteString("]byte\n")

    return nil
}

func (this *CodeGenerator) writeImportStatement() {
	buffer := this.codeSnippets[0]
	buffer.WriteString(`import "github.com/stealthly/go-avro"`)
	buffer.WriteString("\n")
}

func (this *CodeGenerator) writeStructSchemaVar(info *schemaInfo) {
	buffer := this.schemaDefinitions
	buffer.WriteString("// Generated by codegen. Please do not modify.\n")
	buffer.WriteString("var ")
	buffer.WriteString(info.schemaVarName)
	buffer.WriteString(", ")
	buffer.WriteString(info.schemaErrName)
	buffer.WriteString(" = avro.ParseSchema(`")
	buffer.WriteString(info.schema.String())
	buffer.WriteString("`)\n\n")
}

func (this *CodeGenerator) writeDoc(prefix string, doc string, buffer *bytes.Buffer) {
	if doc == "" {
		return
	}

	buffer.WriteString(prefix)
	buffer.WriteString("/* ")
	buffer.WriteString(doc)
	buffer.WriteString(" */\n")
}

func (this *CodeGenerator) writeStructDefinition(info *schemaInfo, buffer *bytes.Buffer) error {
	buffer.WriteString("type ")
	buffer.WriteString(info.typeName)
	buffer.WriteString(" struct {\n")

	for i := 0; i < len(info.schema.Fields); i++ {
		err := this.writeStructField(info.schema.Fields[i], buffer)
		if err != nil {
			return err
		}
	}

	buffer.WriteString("}")

	return nil
}

func (this *CodeGenerator) writeStructField(field *SchemaField, buffer *bytes.Buffer) error {
	this.writeDoc("\t", field.Doc, buffer)
	if field.Name == "" {
		return errors.New("Empty field name.")
	}

	buffer.WriteString("\t")
	buffer.WriteString(strings.ToUpper(field.Name[:1]))
	buffer.WriteString(field.Name[1:])
	buffer.WriteString(" ")

	err := this.writeStructFieldType(field.Type, buffer)
	if err != nil {
		return err
	}

	buffer.WriteString("\n")

	return nil
}

func (this *CodeGenerator) writeStructFieldType(schema Schema, buffer *bytes.Buffer) error {
	switch schema.Type() {
	case Null:
		buffer.WriteString("interface{}")
	case Boolean:
		buffer.WriteString("bool")
	case String:
		buffer.WriteString("string")
	case Int:
		buffer.WriteString("int32")
	case Long:
		buffer.WriteString("int64")
	case Float:
		buffer.WriteString("float32")
	case Double:
		buffer.WriteString("float64")
	case Bytes:
		buffer.WriteString("[]byte")
	case Array:
		{
			buffer.WriteString("[]")
			err := this.writeStructFieldType(schema.(*ArraySchema).Items, buffer)
			if err != nil {
				return err
			}
		}
	case Map:
		{
			buffer.WriteString("map[string]")
			err := this.writeStructFieldType(schema.(*MapSchema).Values, buffer)
			if err != nil {
				return err
			}
		}
	case Enum:
		buffer.WriteString("*avro.GenericEnum")
	case Union:
		{
			err := this.writeStructUnionType(schema.(*UnionSchema), buffer)
			if err != nil {
				return err
			}
		}
	case Fixed:
		{
			fixedSchema := schema.(*FixedSchema)
			if fixedSchema.Name == "" {
				return errors.New("Empty Fixed type name.")
			}
            fixedName := fmt.Sprintf("%s%s", strings.ToUpper(fixedSchema.Name[:1]), fixedSchema.Name[1:])

            buffer.WriteString(fixedName)

            return this.writeFixed(fixedSchema)
		}
	case Record:
		{
			buffer.WriteString("*")
			recordSchema := schema.(*RecordSchema)

			schemaInfo, err := newSchemaInfo(recordSchema)
			if err != nil {
				return err
			}

			buffer.WriteString(schemaInfo.typeName)

			return this.writeStruct(schemaInfo)
		}
        case Recursive: {
            buffer.WriteString("*")
            buffer.WriteString(schema.(*RecursiveSchema).GetName())
        }
	}

	return nil
}

func (this *CodeGenerator) writeStructUnionType(schema *UnionSchema, buffer *bytes.Buffer) error {
    var unionType Schema
    if schema.Types[0].Type() == Null {
        unionType = schema.Types[1]
    } else if schema.Types[1].Type() == Null {
        unionType = schema.Types[0]
    }

    if unionType != nil && this.isNullable(unionType) {
        return this.writeStructFieldType(unionType, buffer)
    }

	buffer.WriteString("interface{}")
	return nil
}

func (this *CodeGenerator) isNullable(schema Schema) bool {
    switch schema.(type) {
        case *BooleanSchema, *IntSchema, *LongSchema, *FloatSchema, *DoubleSchema, *StringSchema: return false
        default: return true
    }
}

func (this *CodeGenerator) writeStructConstructor(info *schemaInfo, buffer *bytes.Buffer) error {
	buffer.WriteString("func New")
	buffer.WriteString(info.typeName)
	buffer.WriteString("() *")
	buffer.WriteString(info.typeName)
	buffer.WriteString(" {\n")
	buffer.WriteString("\treturn &")
	buffer.WriteString(info.typeName)
	buffer.WriteString("{\n")

	for i := 0; i < len(info.schema.Fields); i++ {
		err := this.writeStructConstructorField(info, info.schema.Fields[i], buffer)
		if err != nil {
			return err
		}
	}

	buffer.WriteString("\t}\n")
	buffer.WriteString("}")

	return nil
}

func (this *CodeGenerator) writeStructConstructorField(info *schemaInfo, field *SchemaField, buffer *bytes.Buffer) error {
	if !this.needWriteField(field) {
		return nil
	}

	this.writeStructConstructorFieldName(field, buffer)

	switch field.Type.(type) {
	case *NullSchema:
		buffer.WriteString("nil")
	case *BooleanSchema:
		buffer.WriteString(fmt.Sprintf("%s", field.Default))
	case *StringSchema:
		{
			buffer.WriteString(`"`)
			buffer.WriteString(fmt.Sprintf("%s", field.Default))
			buffer.WriteString(`"`)
		}
	case *IntSchema:
		{
			defaultValue, ok := field.Default.(float64)
			if !ok {
				return fmt.Errorf("Invalid default value for %s field of type %s", field.Name, field.Type.GetName())
			}
			buffer.WriteString(fmt.Sprintf("int32(%d)", int32(defaultValue)))
		}
	case *LongSchema:
		{
			defaultValue, ok := field.Default.(float64)
			if !ok {
				return fmt.Errorf("Invalid default value for %s field of type %s", field.Name, field.Type.GetName())
			}
			buffer.WriteString(fmt.Sprintf("int64(%d)", int64(defaultValue)))
		}
	case *FloatSchema:
		{
			defaultValue, ok := field.Default.(float64)
			if !ok {
				return fmt.Errorf("Invalid default value for %s field of type %s", field.Name, field.Type.GetName())
			}
			buffer.WriteString(fmt.Sprintf("float32(%f)", float32(defaultValue)))
		}
	case *DoubleSchema:
		{
			defaultValue, ok := field.Default.(float64)
			if !ok {
				return fmt.Errorf("Invalid default value for %s field of type %s", field.Name, field.Type.GetName())
			}
			buffer.WriteString(fmt.Sprintf("float64(%f)", defaultValue))
		}
	case *BytesSchema:
		buffer.WriteString("[]byte{}") //TODO not implemented yet
	case *ArraySchema:
		{
			buffer.WriteString("make(")
			err := this.writeStructFieldType(field.Type, buffer)
			if err != nil {
				return err
			}
			buffer.WriteString(", 0)")
		}
	case *MapSchema:
		{
			buffer.WriteString("make(")
			err := this.writeStructFieldType(field.Type, buffer)
			if err != nil {
				return err
			}
			buffer.WriteString(")")
		}
	case *EnumSchema:
		buffer.WriteString("nil") //TODO not implemented yet
	case *UnionSchema:
		buffer.WriteString("nil") //TODO not implemented yet
	case *FixedSchema: {
        buffer.WriteString("make(")
        buffer.WriteString(field.Type.GetName())
        buffer.WriteString(")")
    }
	case *RecordSchema:
		{
			buffer.WriteString("New")
			info, err := newSchemaInfo(field.Type.(*RecordSchema))
			if err != nil {
				return err
			}
			buffer.WriteString(info.typeName)
			buffer.WriteString("()")
		}
	}
	buffer.WriteString(",\n")

	return nil
}

func (this *CodeGenerator) needWriteField(field *SchemaField) bool {
	if field.Default != nil {
		return true
	}

	switch field.Type.(type) {
	case *BytesSchema, *ArraySchema, *MapSchema, *RecordSchema:
		return true
	}

	return false
}

func (this *CodeGenerator) writeStructConstructorFieldName(field *SchemaField, buffer *bytes.Buffer) {
	buffer.WriteString("\t\t")
	fieldName := fmt.Sprintf("%s%s", strings.ToUpper(field.Name[:1]), field.Name[1:])
	buffer.WriteString(fieldName)
	buffer.WriteString(": ")
}

func (this *CodeGenerator) writeSchemaGetter(info *schemaInfo, buffer *bytes.Buffer) {
	buffer.WriteString("func (this *")
	buffer.WriteString(info.typeName)
	buffer.WriteString(") Schema() avro.Schema {\n\t")

	buffer.WriteString("if ")
	buffer.WriteString(info.schemaErrName)
	buffer.WriteString(" != nil {\n\t\t")
	buffer.WriteString("panic(")
	buffer.WriteString(info.schemaErrName)
	buffer.WriteString(")\n\t}\n\t")

	buffer.WriteString("return ")
	buffer.WriteString(info.schemaVarName)
	buffer.WriteString("\n}")
}
